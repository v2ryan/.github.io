<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æš—é»‘å®¿å‘½ - ç­”æ¡ˆä¹‹ä¹¦ (èµ›åšå¢å¼ºç‰ˆ)</title>
    <!-- å¼•å…¥ Google Fonts å¢åŠ ç§‘å¹»ç¥ç§˜æ„Ÿ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Zen+Dots&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Orbitron', sans-serif; }
        
        /* CRT æ‰«æçº¿æ»¤é•œæ•ˆæœ */
        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #ui-layer { position: absolute; top: 20px; left: 20px; color: rgba(200,200,200,0.8); z-index: 10; pointer-events: none; user-select: none; text-shadow: none; }
        .instruction { font-size: 14px; line-height: 1.8; color: #888; border-left: 2px solid #444; padding-left: 15px; }
        .key { color: #4ff; font-weight: bold; }
        #status-text { color: #ccc; letter-spacing: 1px; font-weight: bold; }

        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        /* éšè—è§†é¢‘ä½†ä¿æŒåŠŸèƒ½è¿ä½œ */
        #video-container { position: absolute; top: -1000px; left: -1000px; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        video { width: 100%; height: 100%; object-fit: cover; }

        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #4ff; font-size: 14px; letter-spacing: 4px; text-transform: uppercase; text-shadow: 0 0 10px #0ff;}
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="loader">System Initializing...</div>

    <div id="ui-layer">
        <div class="instruction">
            <p> <span class="key">â‡„ NAVIGATE</span> å³æ‰‹æ‚¬åœç§»åŠ¨</p>
            <p> <span class="key">âœ‹ ACTIVATE</span> å¼ å¼€æ‰‹æŒè“„åŠ›</p>
            <p>STATUS: <span id="status-text">WAITING FOR UPLINK...</span></p>
        </div>
    </div>

    <div id="video-container"><video id="input-video"></video></div>
    
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONF = {
            cardCount: 12,
            cardSpacing: 3.2, 
            chargeTimeNeed: 50, 
            colors: { bg: 0x020205, cursor: 0x44ffff, cursorActive: 0xffffff } 
        };

        const input = { x: 0.5, y: 0.5, isPalmOpen: false, isDetected: false };
        let scrollTarget = 0, scrollCurrent = 0, pinchTimer = 0, activeCardIndex = 0, explosionParticles; 
        const clock = new THREE.Clock(); 

        // --- Scene & Bloom ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONF.colors.bg, 0.035); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 11);

        const renderer = new THREE.WebGLRenderer({ antialias: false, stencil: false, depth: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(CONF.colors.bg);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        // è°ƒæ•´ Bloom å‚æ•°ï¼šå¤§å¹…æé«˜é˜ˆå€¼ï¼Œç¡®ä¿æ–‡å­—ä¸å‘å…‰ï¼Œä»…é«˜äº®ç‰¹æ•ˆå‘å…‰
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.85; // åªæœ‰äº®åº¦è¶…è¿‡ 0.85 çš„åƒç´ æ‰å‘å…‰ï¼ˆæ–‡å­—è®¾ä¸ºç°è‰²å°†ä¸ä¼šå‘å…‰ï¼‰
        bloomPass.strength = 0.8;   // æ¢å¤ä¸€ç‚¹å¼ºåº¦ç»™ç‰¹æ•ˆ
        bloomPass.radius = 0.5;     

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Visuals ---
        const cursorGeo = new THREE.RingGeometry(0.08, 0.1, 32);
        const cursorMat = new THREE.MeshBasicMaterial({ color: CONF.colors.cursor, transparent: true, opacity: 0.5, depthTest: false });
        const cursor = new THREE.Mesh(cursorGeo, cursorMat);
        cursor.position.z = 5;
        scene.add(cursor);

        const chargeGeo = new THREE.RingGeometry(0.12, 0.16, 64, 1, 0, 0);
        const chargeMat = new THREE.MeshBasicMaterial({ color: 0xff0044, side: THREE.DoubleSide, transparent: true, opacity: 0.9, depthTest: false, blending: THREE.AdditiveBlending });
        const chargeRing = new THREE.Mesh(chargeGeo, chargeMat);
        chargeRing.position.z = 5; chargeRing.visible = false;
        scene.add(chargeRing);

        // ç²’å­ç³»ç»Ÿï¼šå¢åŠ éšæœºå¤§å°å’Œæ›´å¤æ‚çš„åˆ†å¸ƒ
        const pGeo = new THREE.BufferGeometry();
        const pCount = 800;
        const pPos = new Float32Array(pCount * 3);
        const pSizes = new Float32Array(pCount);
        const pSpeeds = new Float32Array(pCount); 
        
        for(let i=0; i<pCount; i++) {
            pPos[i*3] = (Math.random()-0.5)*60;
            pPos[i*3+1] = (Math.random()-0.5)*40;
            pPos[i*3+2] = (Math.random()-0.5)*30 - 10;
            pSizes[i] = Math.random();
            pSpeeds[i] = Math.random() * 0.5 + 0.1;
        }
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        
        const pMat = new THREE.PointsMaterial({ size: 0.08, color: 0x6688aa, transparent: true, opacity: 0.4, sizeAttenuation: true });
        const particles = new THREE.Points(pGeo, pMat);
        scene.add(particles);

        function initExplosionSystem() {
            const count = 1500; 
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = new Float32Array(count * 3); 
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                positions[i*3] = 0; positions[i*3+1] = 0; positions[i*3+2] = 0;
                
                const r = 1;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                const speed = Math.random() * 0.3 + 0.05;
                velocities[i*3] = speed * Math.sin(phi) * Math.cos(theta);
                velocities[i*3+1] = speed * Math.sin(phi) * Math.sin(theta);
                velocities[i*3+2] = speed * Math.cos(phi);

                colors[i*3] = 0.8; colors[i*3+1] = 0.8; colors[i*3+2] = 1.0; 
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
            explosionParticles = new THREE.Points(geometry, material);
            explosionParticles.userData.isActive = false;
            scene.add(explosionParticles);
        }
        initExplosionSystem();

        // [æ–°å¢] åˆ›å»º 3D æ ‡é¢˜ (ä¸ºäº†æ”¯æŒè¢«å¡ç‰‡é®æŒ¡ï¼Œå¿…é¡»ä½œä¸ºåœºæ™¯å†…çš„ç‰©ä½“å­˜åœ¨)
        function createTitleMesh() {
            const cvs = document.createElement('canvas');
            cvs.width = 1024; cvs.height = 256;
            const ctx = cvs.getContext('2d');
            
            // ç¡®ä¿å­—ä½“åŠ è½½åå†ç»˜åˆ¶ï¼Œæˆ–è€…ç®€å•çš„é‡è¯•æœºåˆ¶
            document.fonts.ready.then(() => {
                ctx.clearRect(0, 0, 1024, 256);
                ctx.fillStyle = "#dddddd"; 
                ctx.font = "140px 'Zen Dots', cursive"; // åŒ¹é…ç”¨æˆ·æƒ³è¦çš„å·¨å¤§å­—å·æ„Ÿ
                ctx.textAlign = "center"; 
                ctx.textBaseline = "middle";
                ctx.fillText("Answers", 512, 128);
                
                const tex = new THREE.CanvasTexture(cvs);
                tex.needsUpdate = true;
                
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.9 });
                const geom = new THREE.PlaneGeometry(8, 2); // å®½åº¦8å•ä½ï¼Œé«˜åº¦2å•ä½
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(0, 3.8, -2); // æ•´ä½“ä¸Šç§»æ ‡é¢˜ä½ç½®
                scene.add(mesh);
            });
        }
        createTitleMesh();

        // --- Cards ---
        const answers = ["é™ å¾… æ—¶ æœº", "ç» å¯¹ ä¸ å¯", "æ”¾ æ‰‹ ä¸€ æ", "å‘½ å®š ä¹‹ æ•°", "éœ€ è¦ è€ å¿ƒ", "ç›´ è§‰ æŒ‡ å¼•", "é‡ å»º ç§© åº", "è™š å‡ ä¹‹ è±¡", "è´µ äºº å°† è‡³", "ä¿ æŒ ç¼„ é»˜", "å³ åˆ» å¯ ç¨‹", "å† è¯• ä¸€ æ¬¡"];

        function createCardMap(text, isFront) {
            const cvs = document.createElement('canvas');
            cvs.width = 512; cvs.height = 768;
            const ctx = cvs.getContext('2d');
            const w = 512, h = 768;

            const grad = ctx.createLinearGradient(0, 0, w, h);
            grad.addColorStop(0, isFront ? '#222' : '#151515');
            grad.addColorStop(1, '#000');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,w,h);

            for (let i = 0; i < 4000; i++) {
                ctx.fillStyle = `rgba(100,100,120,${Math.random() * 0.08})`;
                ctx.fillRect(Math.random()*w, Math.random()*h, 2, 2);
            }

            ctx.shadowBlur = 20;
            ctx.shadowColor = isFront ? "#44aaff" : "#aa6644";
            ctx.strokeStyle = isFront ? '#446688' : '#553322';
            ctx.lineWidth = 8;
            ctx.strokeRect(20,20,w-40,h-40);
            
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(35,35,w-70,h-70);

            if (isFront) {
                ctx.shadowBlur = 0; // å»é™¤æ–‡å­—å‘å…‰é˜´å½±
                ctx.fillStyle = "#bbbbbb"; // çº¯ç°è‰²æ–‡å­—ï¼Œç¡®ä¿äº®åº¦ä½äº Bloom é˜ˆå€¼
                ctx.font = "bold 60px 'Orbitron', monospace";
                ctx.textAlign = "center"; ctx.textBaseline = "middle";
                
                ctx.fillText(text.replace(/\s+/g, ''), w/2, h/2);

                ctx.strokeStyle = "#446688"; ctx.lineWidth = 3; 
                ctx.beginPath(); 
                ctx.moveTo(100, h/2+50); ctx.lineTo(w-100, h/2+50); 
                ctx.stroke();
            } else {
                ctx.translate(w/2, h/2); 
                ctx.shadowBlur = 25; ctx.shadowColor = "#ff4400";
                const primaryColor = "#aa5533"; 
                
                ctx.strokeStyle = primaryColor; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(0,0, 140, 0, Math.PI*2); ctx.stroke();
                
                ctx.lineWidth = 2;
                for(let i=0; i<6; i++) {
                    ctx.rotate(Math.PI/3);
                    ctx.beginPath(); ctx.moveTo(0, -140); ctx.lineTo(120, 70); ctx.lineTo(-120, 70); ctx.closePath();
                    ctx.stroke();
                }

                ctx.fillStyle = primaryColor; ctx.font = "80px serif"; 
                ctx.textAlign = "center"; ctx.textBaseline="middle"; 
                ctx.fillText("ğŸ‘", 0, 5);
            }
            const tex = new THREE.CanvasTexture(cvs);
            tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return tex;
        }

        const cards = [];
        const cardGroup = new THREE.Group();
        scene.add(cardGroup);
        const cardGeo = new THREE.PlaneGeometry(2.4, 3.6);

        const finalTextMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
        const finalTextPlane = new THREE.Mesh(new THREE.PlaneGeometry(4, 6), finalTextMat);
        finalTextPlane.position.z = 8; finalTextPlane.visible = false;
        scene.add(finalTextPlane);
        
        for (let i = 0; i < CONF.cardCount; i++) {
            const matFront = new THREE.MeshBasicMaterial({ map: createCardMap(answers[i], true), transparent: true });
            const matBack = new THREE.MeshBasicMaterial({ map: createCardMap("", false), transparent: true });
            const cardObj = new THREE.Group();
            const meshFront = new THREE.Mesh(cardGeo, matFront);
            meshFront.rotation.y = Math.PI; meshFront.position.z = -0.01;
            const meshBack = new THREE.Mesh(cardGeo, matBack);
            cardObj.add(meshFront); cardObj.add(meshBack);
            cardObj.userData = { id: i, baseX: i * CONF.cardSpacing };
            cardGroup.add(cardObj);
            cards.push(cardObj);
        }

        document.getElementById('loader').style.display = 'none';

        // --- Logic ---
        let gameState = 'IDLE'; 

        function updateLogic() {
            const time = clock.getElapsedTime();

            const vec = new THREE.Vector3(); const pos = new THREE.Vector3();
            vec.set((input.x * 2) - 1, -(input.y * 2) + 1, 0.5);
            vec.unproject(camera); vec.sub(camera.position).normalize();
            const cursorDist = (5 - camera.position.z) / vec.z;
            pos.copy(camera.position).add(vec.multiplyScalar(cursorDist));
            
            cursor.position.lerp(pos, 0.15); 
            chargeRing.position.copy(cursor.position);
            
            cursor.rotation.z -= 0.05;
            const scalePulse = 1 + Math.sin(time * 3) * 0.05;
            cursor.scale.setScalar(scalePulse);

            if (gameState === 'REVEALED') { updateExplosion(); return; }

            const speed = (input.x - 0.5) * 0.7;
            
            // [ä¼˜åŒ–] å¢åŠ ç£å¸é€»è¾‘ï¼šå½“æ‰‹éƒ¨æ¥è¿‘ä¸­å¿ƒåœæ­¢ç§»åŠ¨æ—¶ï¼Œè‡ªåŠ¨å¸é™„åˆ°æœ€è¿‘çš„å¡ç‰Œ
            if (Math.abs(speed) > 0.06 && !input.isPalmOpen) {
                scrollTarget -= speed;
            } else {
                // è®¡ç®—æœ€è¿‘çš„å¡ä½ç´¢å¼•
                const nearestIdx = Math.round(-scrollTarget / CONF.cardSpacing);
                const snapTarget = -nearestIdx * CONF.cardSpacing;
                // ç¼“æ…¢å¸é™„
                scrollTarget += (snapTarget - scrollTarget) * 0.08;
            }

            // ç§»é™¤è¾¹ç•Œé™åˆ¶å®ç°æ— é™æ»šåŠ¨
            scrollCurrent += (scrollTarget - scrollCurrent) * 0.1;

            const totalW = CONF.cardCount * CONF.cardSpacing;
            let closestDist = 999; let closestIndex = -1;
            
            cards.forEach((c, idx) => {
                // æ— é™å¾ªç¯ä½ç½®è®¡ç®—ï¼šå°†ä½ç½®æ˜ å°„åˆ° [-totalW/2, totalW/2] åŒºé—´
                let realX = (c.userData.baseX + scrollCurrent) % totalW;
                if (realX > totalW / 2) realX -= totalW;
                if (realX < -totalW / 2) realX += totalW;

                c.position.x = realX;
                const distToCenter = Math.abs(realX);
                
                const scale = 1 + Math.exp(-Math.pow(distToCenter * 0.6, 2)) * 0.4; 
                c.scale.setScalar(scale);
                
                // [ä¼˜åŒ–] æ‚¬æµ®åŠ¨æ•ˆ
                const floatY = Math.sin(time * 2 + idx) * 0.05 - 0.5; // æ•´ä½“ä¸Šç§»ï¼Œå‡å°‘ä¸‹æ²‰å¹…åº¦
                
                c.position.y = floatY;
                c.position.z = Math.exp(-Math.pow(distToCenter * 0.45, 2)) * 2.0; 
                
                c.rotation.y = -realX * 0.2 + Math.sin(time * 0.5 + idx) * 0.02;
                
                const opacity = 1 - Math.min(distToCenter / (CONF.cardSpacing * 2.0), 0.9);
                c.children.forEach(mesh => mesh.material.opacity = opacity);
                
                if (distToCenter < closestDist) { closestDist = distToCenter; closestIndex = idx; }
            });
            activeCardIndex = closestIndex;

            const statusEl = document.getElementById('status-text');
            if (input.isPalmOpen && closestIndex !== -1 && Math.abs(cards[closestIndex].position.x) < 0.6) {
                pinchTimer++; 
                gameState = 'CHARGING';
                chargeRing.visible = true;
                
                const progress = pinchTimer / CONF.chargeTimeNeed;
                
                const newGeo = new THREE.RingGeometry(0.12, 0.16, 64, 1, Math.PI/2, progress * Math.PI * 2);
                chargeRing.geometry.dispose(); chargeRing.geometry = newGeo;
                
                const shake = progress * 0.15;
                cards[activeCardIndex].position.x += (Math.random()-0.5) * shake;
                cards[activeCardIndex].position.y += (Math.random()-0.5) * shake;
                
                chargeRing.material.color.setHSL(0.9 - progress * 0.4, 1, 0.5);
                statusEl.innerText = `SYNCING... ${Math.floor(progress*100)}%`;
                statusEl.style.color = "#ff3333";

                if (pinchTimer >= CONF.chargeTimeNeed) revealAnswer(cards[activeCardIndex]);
            } else {
                pinchTimer = 0; if (gameState === 'CHARGING') gameState = 'IDLE';
                chargeRing.visible = false; cursor.material.opacity = 0.5;
                statusEl.innerText = input.isDetected ? "LINKED - OPEN PALM TO SELECT" : "SEARCHING FOR SIGNAL...";
                statusEl.style.color = "#fff";
            }
        }

        function updateExplosion() {
            if (!explosionParticles.userData.isActive) return;
            const positions = explosionParticles.geometry.attributes.position.array;
            const velocities = explosionParticles.geometry.attributes.velocity.array;
            
            for (let i = 0; i < positions.length / 3; i++) {
                positions[i*3] += velocities[i*3];
                positions[i*3+1] += velocities[i*3+1];
                positions[i*3+2] += velocities[i*3+2];
                
                velocities[i*3] *= 0.96; 
                velocities[i*3+1] *= 0.96;
                velocities[i*3+2] *= 0.96;
            }
            explosionParticles.geometry.attributes.position.needsUpdate = true;
            explosionParticles.rotation.y += 0.002;
        }

        function revealAnswer(targetCard) {
            gameState = 'REVEALED';
            document.getElementById('status-text').innerText = "FATE SEALED.";
            document.getElementById('ui-layer').style.opacity = 0.3;
            cursor.visible = false; chargeRing.visible = false;

            gsap.to(bloomPass, { strength: 4.0, radius: 1.5, duration: 0.1, yoyo: true, repeat: 1, ease: "power2.inOut" });
            gsap.to(bloomPass, { strength: 1.5, duration: 2, delay: 0.3 }); 

            cards.forEach(c => {
                if (c !== targetCard) {
                    gsap.to(c.position, { y: -25, duration: 1.5, ease: "power2.in" });
                    gsap.to(c.scale, { x: 0, y: 0, duration: 1 });
                }
            });

            const tl = gsap.timeline();
            
            // ä¼˜åŒ–ï¼šå¡ç‰‡å‰ç§»ã€æ—‹è½¬ã€æ”¾å¤§åŒæ­¥è¿›è¡Œï¼Œå»é™¤ä¸­é—´çš„ç­‰å¾…æ—¶é—´
            tl.to(targetCard.position, { x: 0, y: 0, z: 7, duration: 1.2, ease: "power3.out" })
              .to(targetCard.rotation, { x: 0, y: Math.PI, z: 0, duration: 1.0, ease: "back.out(1.2)" }, "<") 
              .to(targetCard.scale, { x: 1.5, y: 1.5, duration: 1.2 }, "<");
            
            // ä¼˜åŒ–ï¼šåœ¨åŠ¨ç”»å¿«ç»“æŸå‰æå‰è§¦å‘ç²’å­å’Œæ–‡å­—æ˜¾ç°ï¼Œè®©è§†è§‰æ›´ç´§å‡‘
            tl.call(() => {
                const frontTexture = targetCard.children[0].material.map;
                finalTextMat.map = frontTexture; finalTextMat.needsUpdate = true;
                finalTextPlane.visible = true; finalTextPlane.position.copy(targetCard.position); 
                explosionParticles.position.copy(targetCard.position);
                explosionParticles.userData.isActive = true;
                
                // ç²’å­çˆ†å‘
                gsap.to(explosionParticles.material, { opacity: 0.8, duration: 0.1 });
                gsap.to(explosionParticles.material, { opacity: 0, duration: 3, delay: 0.5 });
                
                // å®ä½“å¡ç‰‡æ·¡å‡ºï¼Œçº¯æ–‡å­—æµ®ç°
                gsap.to(targetCard.children[0].material, { opacity: 0, duration: 0.2 });
                gsap.to(targetCard.children[1].material, { opacity: 0, duration: 0.2 });
                gsap.to(finalTextMat, { opacity: 1, duration: 0.5 });
            }, null, "-=0.4"); 
        }

        window.addEventListener('mousemove', e => {
            if (!input.isDetected) { input.x = e.clientX / window.innerWidth; input.y = e.clientY / window.innerHeight; }
        });
        window.addEventListener('mousedown', () => { if(!input.isDetected) input.isPalmOpen = true; });
        window.addEventListener('mouseup', () => { if(!input.isDetected) input.isPalmOpen = false; });

        const videoElement = document.getElementById('input-video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults(results => {
            input.isDetected = false; 
            input.isPalmOpen = false;
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (let i = 0; i < results.multiHandedness.length; i++) {
                    const label = results.multiHandedness[i].label;
                    if (label === 'Left') { 
                        input.isDetected = true;
                        const lm = results.multiHandLandmarks[i]; 
                        const i8 = lm[8];
                        input.x += ((1 - i8.x) - input.x) * 0.5; 
                        input.y += (i8.y - input.y) * 0.5;

                        const tips = [8, 12, 16, 20];
                        const pips = [6, 10, 14, 18]; 
                        let extendedCount = 0;
                        for (let k = 0; k < 4; k++) { if (lm[tips[k]].y < lm[pips[k]].y) extendedCount++; }
                        if (Math.abs(lm[4].x - lm[2].x) > 0.03) extendedCount++;

                        input.isPalmOpen = (extendedCount >= 4);
                        break; 
                    }
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        function animate() {
            requestAnimationFrame(animate);
            updateLogic();
            
            const time = clock.getElapsedTime();
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<pCount; i++){
                positions[i*3+1] += Math.sin(time * pSpeeds[i] + positions[i*3]) * 0.02;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = time * 0.05;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>